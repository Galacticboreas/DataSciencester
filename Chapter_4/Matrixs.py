from typing import List

# ---------------
#    Матрицы    |
# ---------------

# Матрица - это двумерная коллекция чисел. Мы будем реализовывать
# матрицы как списки списков, где все внутренние списки имеют
# одинаковый размер и представляют строку матрицы. Если А - это матрица,
# то А[i][j] - это элемент в i-й строке и j-м столбце. В соответствии
# с правилами математической записи для обозначения матриц мы будем
# в основном использовать заглавные буквы. Например:

# Еще один псевдоним типа
Matrix = List[List[float]]

A = [[1, 2, 3],     # Матрица А имеет 2 строки и 3 столбца
     [4, 5, 6]]

B = [[1, 2],        # Матрица B имеет 3 строки и 2 столбца
     [3, 4],
     [5, 6]]

# Представленная в виде списка списков матрица А имеет len(A) строк и
# len(A[0]) столбцов. Эти значения образуют форму матрицы:

from typing import Tuple

def shape(A: Matrix) -> Tuple[int, int]:
     """Возвращает (число строк А, число тобцов А)"""
     num_rows = len(A)
     num_cols = len(A[0]) if A else 0   # Число элементов в первой строке
     return num_rows, num_cols

assert shape([[1, 2, 3], [4, 5, 6]]) == (2, 3)   # 2 строки, 3 столбца

# Если матрица имеет n строк и k столбцов, то мы будем говорить, что это
# (n x k)-матрица, или матрица размера n x k. Каждая строка (n x k)-матрицы
# может быть представлена вектором длины k, а каждый столбец - вектором длины n:

Vector = List[float]

def get_row(A: Matrix, i: int) -> Vector:
     """Возвращаем i-ю строку А (как тип Vector)"""
     return A[i]             # A[i] является i-й строкой

def get_column(A: Matrix, j: int) -> Vector:
     """Возвращает j-й столбец А (как тип Vector)"""
     return [A_i[j]          # j-й элемент строки A_i
             for A_i in A]   # для каждой строки A_i

# Нам также потребуется возможность создавать матрицу при наличии ее формы
# и функции, которая генерирует ее элементы. Это можно сделать на основе
# вложенного включения в список:
from typing import Callable

def make_matrix(num_rows: int,
                num_cols: int,
                entry_fn: Callable[[int, int], float]) -> Matrix:
     """
     Возвращает матрицу размера num_rows x num_cols,
     чей (i, j)-й элемент является функцией entry_fn(i, j)
     """
     return [[entry_fn(i, j)              # Создать список с учетом i
              for j in range(num_cols)]   # [entry_fn(i, 0), ...]
             for i in range(num_rows)]    # Создать один список для каждого i
# При наличии этой функции можно, например, создать (5 х 5)-мартицу 
# тождественности (с единицами по диагонали и нулями в остальных элементах):
def identity_matrix(n: int) -> Matrix:
     """
     Возвращает (n x n)-матрицу тождественности,
     также именуемую единичной
     """
     return make_matrix(n, n, lambda i, j: 1 if i == j else 0)

assert identity_matrix(5) == [[1, 0, 0, 0, 0],
                              [0, 1, 0, 0, 0],
                              [0, 0, 1, 0, 0],
                              [0, 0, 0, 1, 0],
                              [0, 0, 0, 0, 1]]

# Матрицы будут для нас важны по нескольким причинам.
# Во первых, мы можем использовать матрицу для представления набора
# данных, состоящего из нескольких векторов, рассматривая каждый вектор
# как строку матрицы. Например, если бы у вас были данные о росте,
# массе и возрасте 1000 человек, то их можно преставить в виде 
# (1000 х 3)-матрицы:
data = [[70, 170, 40],
        [65, 120, 26],
        [77, 250, 19],
        # ...
        ]
# Во вторых, как мы убедимся далее, (n x k)-матрицу можно использовать
# в качестве линейной функции, которая отображает k-размерные векторы
# в n-размерные векторы. Некоторые наши технические решения и концепции
# будут привлекать такие функции.

# И, в третьих, матрицы можно использовать для представления бинарных
# связей. В главе 1 мы представили ребра сети как коллекцию пар (i, j).
# Альтернативная реализация состоит в создании матрицы смежности, т.е.
# матрицы А, такой, что ее элемент A[i][j] равен 1, если узлы i и j сое-
# динены между собой, и 0 - в противном случае.

# Вспомните, что ранее у нас длужеские связи были списком кортежей:
friendships = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4),
               (4, 5), (5, 6), (5, 7), (6, 8), (7, 8), (8, 9)]

# Мы можем представить то же самое следующим образом:
# Пользователь  0  1  2  3  4  5  6  7  8  9
# 
friendships = [[0, 1, 1, 0, 0, 0, 0, 0, 0, 0],    # Пользователь 0
               [1, 0, 1, 1, 0, 0, 0, 0, 0, 0],    # Пользователь 1
               [1, 1, 0, 1, 0, 0, 0, 0, 0, 0],    # Пользователь 2
               [0, 1, 1, 0, 1, 0, 0, 0, 0, 0],    # Пользователь 3
               [0, 0, 0, 1, 0, 1, 0, 0, 0, 0],    # Пользователь 4
               [0, 0, 0, 0, 1, 0, 1, 1, 0, 0],    # Пользователь 5
               [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],    # Пользователь 6
               [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],    # Пользователь 7
               [0, 0, 0, 0, 0, 0, 1, 1, 0, 1],    # Пользователь 8
               [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]]    # Пользователь 9

# Если дружеских саязей немного, то такое представление имеет гораздо
# меньшую эффективность, т.к. приходится хранить много нулей. Однако
# в таком матричном представлении проверка наличия связи между двумя
# узлами выполняется намного быстрее - вместо того, чтобы обследовать
# каждое ребро в списке, нам нужно всего лишь заглянуть в матрицу:
friendships[0][2] == 1     # True, 0 и 2 являются друзьями
friendships[0][8] == 1     # False, 0 и 8 не являются друзьями

# Схожим образом, для того чтобы найти связи узла, вам нужно лишь
# обследовать столбец (или строку), соответствующий этому узлу:

# Нужно взглянуть лишь на одну строку
friends_of_five = [i 
                   for i, is_friend in enumerate(friendships[5])
                   if is_friend]
# С малым графом, ускоряя этот процесс, вы могли бы просто добавлять
# список связей в каждый узловой объект, но в случае крупного 
# эволюционирующего графа, это вероятно, будет стоить слишком дорого
# и будет усложнять сопровождение.
# Мы будем постоянно возвращаться к теме матриц на протяжении всей книги.
