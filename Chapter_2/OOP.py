# --------------------------
# Объектно ориентированное |
#    программирование      |
# --------------------------

# Здесь мы построим класс, который описывает работу "счетчика нажатий",
# используемого в дверях для отслеживания количества людей, приходящих
# на собрания профессионалов "Продвинутые темы в науке о данных".

# Он поддерживает счетчик, может быть нажат, увеличивая количество,
# позволяет читать количество посредством метода read_count и может
# обнуляться. (В реальной жизни один из них циклически сбрасывается
# с 9999 до 0000, но мы не будем этим утруждаться.)

# Для определения класса используется ключевое слово class и
# ГорбатоеИмя:
class CountingClicker:
    """
    Класс может/должен иметь документирующее
    строковое значение docstring, как функцию
    """

    # Класс содержит ноль или более функций-членов, или компонентных
    # функций. По соглашению каждый член принимает первый параметр self,
    # который ссылается на конкретный экземпляр класса.

    # Как правило, у класса есть конструктор под названием __init__.
    # Он принимает любые параметры, необходимые для конструирования
    # экземпляра вашего класса, и выполняет все настроечные работы,
    # которые вам требуются:
    def __init__(self, count = 0):
        self.count = count

    # Еще одним таким методом является метод __repr__, который
    # создает строковое представление эеземпляра класса:
    def __repr__(self) -> str:
        return f"CountingClicker(count={self.count})"

    # И наконец, нам нужно имплементировать публичный API нашего
    # класса:
    def click(self, num_times = 1):
        """Кликнуть на кликере несколько раз."""
        self.count += num_times

    def read(self):
        return self.count

    def reset(self):
        self.count = 0


# Хотя конструктор имеет замысловатое имя, мы создаем экземпляры
# счетчика нажатий, используя только имя класса:

clicker1 = CountingClicker()            # Инициализируем нулем
clicker2 = CountingClicker(100)         # Стартует со счетчиком, равным 100
clicker3 = CountingClicker(count=100)   # Более явный способ сделать то же самое

clicker = CountingClicker()
assert clicker.read() == 0, "счетчик должен начинаться со значения 0"
clicker.click()
clicker.click()
assert clicker.read() == 2, "после двух нажатий счетчик дожен иметь значение 2"
clicker.reset()
assert clicker.read() == 0, "после сброса счетчика должен вернуться к 0"

# Подкласс наследует все поведение от своего родительского класса.
class NoResetClicker(CountingClicker):
    # Этот класс имеет все те же самые методы, что и у CountingClicker

    # За исключением того, что его метод сброса reset ничего не делает.
    def reset(self):
        pass

clicker2 = NoResetClicker()
assert clicker2.read() == 0
clicker2.click()
assert clicker2.read() == 1
clicker2.reset()
assert clicker2.read() == 1, "Функция reset не дожна ничего делать"
