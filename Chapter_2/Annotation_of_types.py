# -----------------
# Аннотация типов |
# -----------------

# Python - это динамически типизированный язык. Это означает,
# что он вообще не заботиться о типах объектов, которые мы
# используем, при условии, что мы применяем их приемлимыми
# способами:
def add(a, b):
    return a + b

assert add(10, 5) == 15, "+ является допустимым для чисел"
assert add([1, 2], [3]) == [1, 2, 3], "+ является допустимым для списков"
assert add("Эй, ", "привет!") == "Эй, привет!", "+ является допустимым для строк"

try:
    add(10, "пять")
except TypeError:
    print("Невозможно прибавить целое число к строке")

# тогда как в статически типизированном языке наши функции и объекты
# имели бы конкретные типы:
def add(a: int, b: int) -> int:
    return a + b

assert add(10, 5) == 15, "Вы хотели бы, чтобы это работало"
try:
    add("Эй, ", "там")
except TypeError:
    print("Вы хотели бы, чтобы это не работало")

# На самом деле недавние версии Python (вроде) имеют этот функционал.
# Приведенныя выше версия функции add с аннотацией типа int допустима
# в Python 3.6!
# Однако эти аннотации типов в общем-то ничего не делают. Вы по-прежнему
# можете использовать аннотированную функцию add для добавления строк, и
# вызов add(10, "пять") по-прежнему будет поднимать ту же ошибку TypeError.

# Тем не менее есть еще (по крайней мере) четыре веские причины использовать
# аннотации типов в коде Pyhton.

# Типы являются важной формой документирования. Это вдвойне верно в книге,
# в которой используется исходный код для того, чтобы обучить вас теоритиче-
# ским и математическим понятиям. Сравните следующие две заглушки функций:
def dot_product(x, y): ...

# Мы еще не определили Vector, но представим, что мы это сделали
Vector = {}
def dot_product(x: Vector, y: Vector) -> float: ...
# Второй вариант чрезвычайно информативен.

# Необходимость думать о типах в коде заставляет вас разрабатывать более
# чистые функции и интерфейсы:
from typing import Union

def secretly_ugly_function(value, operation): ...

def ugly_function(value: int,
                  operation: Union[str, int, float, bool]) -> int: ...
# Здесь мы имеем функцию, чей параметр operation может быть значением
# с типом str, либо int, либо float, либо bool. Весьма вероятно, что эта
# функция явлеяется хрупкой, и ее трудно использовать, но она становится
# гораздо яснее, когда типы становятся явными. Это заставит нас проектиро-
# вать менее неуклюже, за что наши пользователи будут нам только благодарны.

# Использование типов дает возможность вашему редактору помогать вам с
# такими вещами, как автозаполнение и сообщать о своем недовольстве при
# встрече ошибок.

# Как писать аннотации типов

# Как мы видели, для встроенных типов, таких как int, bool и float, вы
# просто используете сам тип в качестве аннотации. Что, если у вас был
# (скажем) список?
def total(xs: list) -> float:
    return sum(total)

# Это не является неправильным, но тип недостаточно специфичен. Совершенно
# очевидно, что мы на самом деле хотим, чтобы xs был списком из вещественных
# float, а не (скажем) списком строк.

# Модуль typing предоставляет ряд параметров типов, которые мы можем для
# этого использовать:
from typing import List     # Обратите внимание на заглавную L

def total(xs: List[float]) -> float:
    return sum(total)

# Вот так аннотируются переменные при их определении.
# Но это не является необходимым; очевидно, что х имеет тип int.
x: int = 5

# Однако иногда это не так очевидно:
values = []          # Какой у меня тип?
best_so_far = None   # Какой у меня тип?

# В таких случаях мы предоставим внутристрочные (inline) подсказки
# типа:
from typing import Optional

values: List[int] = []
best_so_far: Optional[float] = None  # Допустимо иметь тип float либо None

# Модуль typing содержит много других типов, только некоторые из которых
# мы когда-либо будем использовать:

# Все аннотации типов в этом фрагменте не являются необходимыми
from typing import Dict, Iterable, Tuple

# Ключи являются строками, значения - целыми числами
counts: Dict[str, int] = {'data': 1, 'science': 2}

# Списки и генераторы являются итерируемыми объектами
lazy = []
if lazy:
    evens: Iterable[int] = (x for x in range(10) if x % 2 == 0)
else:
    evens = [0, 2, 4, 6, 8]

# Кортежи конкретизируют тип каждого элемента
triple: Tuple[int, float, int] = (10, 2.3, 5)

# Наконец, поскольку функции в Python используются как объекты первого класса,
# нам нужен тип для их представления. Вот довольно надуманный пример:
from typing import Callable

# Подсказка типа говорит, что repeater - это функция, которая принимает
# два аргумента с типами str и int и возвращает тип str.
def twice(repeater: Callable[[str, int], str], s: str) -> str:
    return repeater(s, 2)

def comma_repeater(s: str, n: int) -> str:
    n_copies = [s for _ in range(n)]
    return ', '.join(n_copies)

assert twice(comma_repeater, "подсказки типов") == "подсказки типов, подсказки типов"

# Поскольку аннотации типов - это просто объекты Python, мы можем их назначать
# переменным для упрощения ссылки на них:
Number = int
Numbers = List[Number]

def total(xs: Numbers) -> Number:
    return sum(xs)

# К концу книги вы уже будете хорошо знакомы с чтением и написанием аннотаций,
# и я надеюсь, что вы будете использовать их в своем коде.
