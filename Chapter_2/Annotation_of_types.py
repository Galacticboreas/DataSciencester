# -----------------
# Аннотация типов |
# -----------------

# Python - это динамически типизированный язык. Это означает,
# что он вообще не заботиться о типах объектов, которые мы
# используем, при условии, что мы применяем их принмлемыми
# способами:
def add(a, b):
    return a + b

assert add(10, 5) == 15, "+ является допустимым для чисел"
assert add([1, 2], [3]) == [1, 2, 3], "+ является допустимым для списков"
assert add("Эй, ", "привет!") == "Эй, привет!", "+ является допустимым для строк"

# try:
#     add(10, "пять")
# except TypeError:
#     print("Невозможно прибавить целое число к строке")

# тогда как в статически типизированном языке наши функции и объекты
# имели бы конкретные типы:
def add(a: int, b: int) -> int:
    return a + b

assert add(10, 5) == 15, "Вы хотели бы, чтобы это работало"
try:
    add("Эй, ", "там")
except TypeError:
    print("Вы хотели бы, чтобы это не работало")

# На самом деле недавние версии Python (вроде) имеют этот функционал.
# Приведенныя выше версия функции add с аннотацией типа int допустима
# в Python 3.6!
# Однако эти аннотации типов в общем-то ничего не делают. Вы по-прежнему
# можете использовать аннотированную функцию add для добавления строк, и
# вызов add(10, "пять") по-прежнему будет поднимать ту же ошибку TypeError.

# Тем не менее есть еще (по крайней мере) четыре веские причины использовать
# аннотации типов в коде Pyhton.

# Типы являются важной формой документирования. Это вдвойне верно в книге,
# в которой используется исходный код для того, чтобы обучить вас теоритиче-
# ским и математическим понятиям. Сравните следующие две заглушки функций:
def dot_product(x, y): ...

# Мы еще не определили Vector, но представим, что мы это сделали
Vector = {}
def dot_product(x: Vector, y: Vector) -> float: ...
# Второй вариант чрезвычайно информативен.

# Необходимость думать о типах в коде заставляет вас разрабатывать более
# чистые функции и интерфейсы:
from typing import Union

def secretly_ugly_function(value, operation): ...

def ugly_function(value: int,
                  operation: Union[str, int, float, bool]) -> int: ...


