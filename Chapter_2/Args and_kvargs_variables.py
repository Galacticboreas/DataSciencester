# --------------------------
# Переменные args и kwargs |
# --------------------------

# Предположим, нужно создать функцию высшего порядка, которая
# в качестве входа принимает некую функцию f и возвращает новую
# функцию, которая для любого входа возвращает удвоенное
# значение f:

# Удвоитель
def doubler(f):
    # Здесь мы определяем новую функцию, которая содержит ссылку на f
    def g(x):
        return 2 * f(x)

    # И возвращает эту новую функцию
    return g

# В некоторых случаях это работает:
def f1(x):
    return x + 1

g = doubler(f1)

assert g(3) == 8, "(3 + 1) * 2 должно быть равно 8"
assert g(-1) == 0, "(-1 + 1) * 2 должно быть равно 0"

# Но терпить неудачу с функциями, которые принимают более одного
# аргумента:
def f2(x, y):
    return x + y

g = doubler(f2)
try:
    g(1, 2)
except TypeError:
    print("По определению g принимает только один аргумент")

# Нам же нужен способ определения функции, которая принимает
# произвольное число аргументов. Это делается при помощи
# распаковки аргументов и небольшого волшебства:
def magic(*args, **kwargs):
    print("Безымянные аргументы: ", args)
    print("Аргументы по ключу: ", kwargs)

magic(1, 2, key="word", key2="word2")
# Напечатает
# Безымянные аргументы: (1, 2)
# Аргументы по ключу: {'key2': 'word2', 'key': 'word'}

# То есть когда функция определена подобным образом, переменная
# args представляет собой кортеж из безымянных позиционных 
# аргументов, а переменная kwargs - словарь из именнованных
# аргументов. Она работает и по-другому, если необходимо использовать
# список (или кортеж) и словарь для передачи аргументов в функцию:
def other_way_magic(x, y, z):
    return x + y + z

x_y_list = [1, 2]
z_dict = {'z': 3}
assert other_way_magic(*x_y_list, **z_dict) == 6, "1 + 2 + 3 должно быть равно 6"

# Эти свойства переменных args и kwargs позволяют проделывать разного рода
# замысловатые трюки. Эдесь этот прием будет использоваться исключительно
# для создания функций высшего порядка, которые могут принимать произвольное
# число входящих аргументов:

# Исправленный удвоитель:
def doubler_correct(f):
    """Работает независимо от того, какого рода аргументы
    функция f ожидает"""
    def g(*args, **kwargs):
        """Какими бы ни были аргументы для g, передать их прямиком в f"""
        return 2 * f(*args, **kwargs)
    return g

g = doubler_correct(f2)
print(g(1, 2))   # равно 6

# Как правило, ваш код будет правильнее и читабельнее, если вы четко указываете,
# какие аргументы требуются вашим функциям; соответственно, мы будем использовать
# args и kwargs только тогда, когда у нас нет другого варианта.
