# Центральные тенденции

# Обычно мы хотим имень некое представление о том, где наши данные
# центрированы. Чаще всего для этих целей используется среднее (или
# среднее арифметическое) значение, которое берется как сумма данных,
# деленная на их количество:

# Среднее значение
from typing import Counter, List
from matplotlib import pyplot as plt

num_friends = [100.0,49,41,40,25,21,21,19,19,18,18,16,15,15,15,15,14,14,13,
            13,13,13,12,12,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
            9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,8,8,8,8,8,8,8,8,8,8,8,8,8,7,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
            6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4,4,4,4,4,4,4,4,4,4,4,
            4,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,
            2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,1,1,1]

def mean(xs: List[float]) -> float:
    return sum(xs) / len(xs)

mean(num_friends)    # 7.333333

# Мы напишем разные функции для четного и нечетного случаев и объединим их:

# Символы подчеркивания указывают на то, что эти функции являются
# "приватными", т.к. они предназначены для вызова из нашей функции median,
# а не другими людьми, использующими нашу статистическую библиотеку
def _median_odd(xs: List[float]) -> float:
    """Если len(xs) является нечетной,
       то медиана - это средний элемент"""
    return sorted(xs)[len(xs) // 2]

def _median_even(xs: List[float]) -> float:
    """Если len(xs) является четной, то она является средним значением
       двух срединных элементов"""
    sorted_xs = sorted(xs)
    hi_midpoint = len(xs) // 2   # напр. длина 4 => hi_midpoint 2
    return (sorted_xs[hi_midpoint - 1] + sorted_xs[hi_midpoint]) / 2

def median(v: List[float]) -> float:
    """Отыскивает 'ближайшее к середине' значение v"""
    return _median_even(v) if len(v) % 2 == 0 else _median_odd(v)

assert median([1, 10, 2, 9, 5]) == 5
assert median([1, 9, 2, 10]) == (2 + 9) / 2

# И теперь мы можем вычислить медианное число друзей:
print(median(num_friends))     # 6

# Вместе с тем среднее значение очень чувствительно к выбросам в данных.
# Если бы самый дружелюбный пользователь имел 200 друзей (вместо 100), то 
# среднее увеличилось бы до 7.82, а медиана осталась бы на прежнем уровне.
# Так как выбросы являются, скорее всего, плохими данными (или иначе - 
# нерепрезентативными для ситуации, которую мы пытаемся понять), то среднее
# может иногда давать искаженную картику. В качестве примера часто приводят
# историю, как в середине 1980-х годов в Университете Северной Каролины
# география стала специализацией с самой высокой стартовой среднестатистической
# зарплатой, что произошло в основном из-за звезды НБА 
# (и выброса) Майкла Джордана.

# Обобщение медианы является квантиль, который представляет значение, ниже
# которого располагается определенный процентиль данных (медиана представляет
# значение, ниже которого расположены 50% данных.)
def quantile(xs: List[float], p: float) -> float:
    """Возвращает значение р-го процентиля в х"""
    p_index = int(p * len(xs))     # Преобразует % в индекс списка
    return sorted(xs)[p_index]

assert quantile(num_friends, 0.10) == 1
assert quantile(num_friends, 0.25) == 3     # Нижний квантиль
assert quantile(num_friends, 0.75) == 9     # Верхний квантиль
assert quantile(num_friends, 0.90) == 13

# Реже вам может понадобиться мода - значение или значения, которые встречаются
# наиболее часто:
def mode(xs: List[float]) -> List[float]:
    """Возвращает список, т.к. может быть более одной моды"""
    counts = Counter(xs)
    max_count = max(counts.values())
    return [xs_i for xs_i, count in counts.items()
            if count == max_count]

assert set(mode(num_friends)) == {1, 6}
# Но чаще всего мы будем просто использовать среднее значение

# Вариация

# Вариация служит мерой разброса наших данных. Как правило, это
# статистические показатели, у которых значения, близкие к нулю,
# означают полное отсутствие разброса, а большие значения (что бы
# это ни значило) - очень большой разброс.
# Например, самым простым показателем явлеяется размах, который
# определяется как разница между максимальным и минимальным значениями
# данных:

# Ключевое слово "range" (размах) в Python уже имеет
# свой смысл, поэтому берем другое
def data_range(xs: List[float]) -> float:
    return max(xs) - min(xs)

assert data_range(num_friends) == 99


# Как и медиана, размах не особо зависит от всего набора данных.
# Набор данных, все точки которого равны 0 или 100, имеет тот же размах,
# что и набор данных, чьи значения представленны числами 0, 100 и 
# большого количества чисел 50, хотя кажется, что первый набор "должен"
# быть разбросан больше.

# Более точным показателем вариации является дисперсия, вычисляемая как:

def sum_of_squares(xs: List[float]) -> float:
    return sum(x ** 2 for x in xs)

def de_mean(xs: List[float]) -> List[float]:
    """Транслировать xs путем вычитания его среднего
        (результат имеет нулевое среднее)"""
    x_bar = mean(xs)
    return [x - x_bar for x in xs]

def variance(xs: List[float]) -> float:
    """Почти среднеквадратическое отклонение от среднего"""
    assert len(xs) >= 2, "дисперсия требует наличия не менее двух элементов"

    n = len(xs)
    deviations = de_mean(xs)
    return sum_of_squares(deviations) / (n - 1)

assert 81.54 < variance(num_friends) < 81.55

import math

def standard_deviation(xs: List[float]) -> float:
    """Стандартное отклонение - это корень квадратный из дисперсии"""
    return math.sqrt(variance(xs))

assert 9.02 < standard_deviation(num_friends) < 9.043

# Размах и стандартное отклонение имеют ту же проблему с выбросами, что и
# среднее. Используя тот же самый пример, отметим: если бы у самого дружелюбного
# пользователя было 200 друзей, то стандартное отклонение было бы 14.89, или
#  на 60% выше!

# Более надежной альтернативой является вычисление интерквартильного размаха
# или разности между значением, соотвествует 75% данных, и значение, соот-
# ветствующим 25% данных:

def interquartile_range(xs: List[float]) -> float:
    """Возвращает разницу между 75%-ным и 25%-ным квартилями"""
    return quantile(xs, 0.75) - quantile(xs, 0.25)

assert interquartile_range(num_friends) == 6
print(interquartile_range(num_friends))

# который очевидным образом не находится под влиянием небольшого
# числа выбросов.

# Корреляция

# Сперва обратимся к ковариации - парному аналогу дисперсии. В отличие от
# дисперсии, которая измеряет отклонение одной-единственной переменной от
# ее среднего, ковариация измеряет отклонение двух переменных в тандеме от
# своих средних:

import numpy as np

daily_minutes = [1,68.77,51.25,52.08,38.36,44.54,57.13,51.4,41.42,31.22,34.76,
                54.01,38.79,47.59,49.1,27.66,41.03,36.73,48.65,28.12,46.62,35.57,
                32.98,35,26.07,23.77,39.73,40.57,31.65,31.21,36.32,20.45,21.93,
                26.02,27.34,23.49,46.94,30.5,33.8,24.23,21.4,27.94,32.24,40.57,
                25.07,19.42,22.39,18.42,46.96,23.72,26.41,26.97,36.76,40.32,35.02,
                29.47,30.2,31,38.11,38.18,36.31,21.03,30.86,36.07,28.66,29.08,
                37.28,15.28,24.17,22.31,30.17,25.53,19.85,35.37,44.6,17.23,13.47,
                26.33,35.02,32.09,24.81,19.33,28.77,24.26,31.98,25.73,24.86,16.28,
                34.51,15.23,39.72,40.8,26.06,35.76,34.76,16.13,44.04,18.03,19.65,
                32.62,35.59,39.43,14.18,35.24,40.13,41.82,35.45,36.07,43.67,24.61,
                20.9,21.9,18.79,27.61,27.21,26.61,29.77,20.59,27.53,13.82,33.2,25,
                33.1,36.65,18.63,14.87,22.2,36.81,25.53,24.62,26.25,18.21,28.08,
                19.42,29.79,32.8,35.99,28.32,27.79,35.88,29.06,36.28,14.1,36.63,
                37.49,26.9,18.58,38.48,24.48,18.95,33.55,14.24,29.04,32.51,25.63,
                22.22,19,32.73,15.16,13.9,27.2,32.01,29.27,33,13.74,20.42,27.32,
                18.23,35.35,28.48,9.08,24.62,20.12,35.26,19.92,31.02,16.49,12.16,
                30.7,31.22,34.65,13.13,27.51,33.2,31.57,14.1,33.42,17.44,10.12,
                24.42,9.82,23.39,30.93,15.03,21.67,31.09,33.29,22.61,26.89,23.48,
                8.38,27.81,32.35,23.84]

daily_hours = [dm / 60 for dm in daily_minutes]

def covariance(xs: List[float], ys: List[float]) -> float:
    assert len(xs) == len(ys), "xs и ys должны иметь одинаковое число эл-ов"
    return np.dot(de_mean(xs), de_mean(ys)) / (len(xs) - 1)

assert 22.42 < covariance(num_friends, daily_minutes) < 22.43
assert 22.42 / 60 < covariance(num_friends, daily_hours) < 22.43 / 60

# Вспомните, что функция dot суммирует произведения соответствующих пар эле-
# ментов. Когда соответствующие элементы обоих векторов х и у одновременно
# выше или ниже своих средних, то в сумму входит положительное число.
# Когда один из них находится выше своего среднего, а другой - ниже, то в 
# сумму входит отрицательное число. Следовательно, "большая" положительная
# ковариация означает, что х стремится принимать большие значения при больших
# значениях у и малые значения - при малых значениях у. "Большая" 
# отрицательная ковариация означает обратное - х стремиться принимать малые
# значения при большом у, и наоборот. Ковариация, близкая к нулю, означает,
# что такой связи не существует.

# Тем не менее этот показатель бывает трудно интерпретировать, и вот почему:
# - единицами измерения ковариации являются произведения единиц входящих
#   переменных (например, число друзей и минуты в день), которые трудно
#   понять (что такое "друг в минуту в день?");

# - если бы у каждого пользователя было в 2 раза больше друзей (но такое же
#   количество минут, проведенных на веб-сайте), то ковариация была бы в 2
#   раза больше. Однако в некотором смысле степень взаимосвязи между ними
#   осталась бы на прежнем уровне. Говоря иначе, трудно определить, что 
#   считать "большой" ковариацией.

# Поэтому чаще обращаются к корреляции, в которой ковариация распределяется
# между стандартными отклонениями обеих переменных:

def correlation(xs: List[float], ys: List[float]) -> float:
    """Измеряет степень, с которой xs и ys варьируются
       в тандеме вокруг своих средних"""
    stdev_x = standard_deviation(xs)
    stdev_y = standard_deviation(ys)
    if stdev_x > 0 and stdev_y > 0:
        return covariance(xs, ys) / stdev_x / stdev_y
    else:
        return 0 # если вариации нет, то корреляция равна

assert 0.24 < correlation(num_friends, daily_minutes) < 0.25
assert 0.24 < correlation(num_friends, daily_hours) < 0.25

# Корреляция является безразмерной величиной, ее значения всегда лежат
# между -1 (идеальная антикорреляция) и 1 (идеальная корреляция). Так,
# число 0.25 представляет собой относительно слабую положительную кор-
# реляцию.

# Впрочем, мы забыли сделать одну вещь - проверить наши данные.
# Посмотрим на рис:
# Человек, у которого 100 друзей, проводит на веб-сайте всего одну минуту
# в день, и поэтому он представляет собой "дикий" выброс, а корреляция,
# как будет показано далее, может быть очень чувствительной к выбросам.
# Что произойдет, если мы проигнорируем этот выброс?

plt.scatter(num_friends, daily_minutes)
plt.title("Корреляция с наличием выброса")
plt.xlabel("Число друзей")
plt.ylabel("Число минут в день")
plt.axis([0, 105, 0, 100])
plt.show()

# Отфильтровать выброс
outlier = num_friends.index(100)  # Индекс выброса

num_friends_good = [x
                    for i, x in enumerate(num_friends)
                    if i != outlier]

daily_minutes_good = [x
                     for i, x in enumerate(daily_minutes)
                     if i != outlier]

daily_hours_good = [dm / 60 for dm in daily_minutes_good]

assert 0.57 < correlation(num_friends_good, daily_minutes_good) < 0.58
assert 0.57 < correlation(num_friends_good, daily_hours_good) < 0.58

# Без выброса получается более сильная корреляция.

# Вы исследуете данные дальше и обнаруживаете, что выброс на самом деле
# оказался техническим тестовым аккаунтом, который забыли удалить, и вы
# поступили совершенно правильно, исключив его из рассмотрения.

plt.scatter(num_friends_good, daily_minutes_good)
plt.title("Корреляция после удаления выброса")
plt.xlabel("Число друзей")
plt.ylabel("Число минут в день")
plt.axis([0, 50, 0, 100])
plt.show()
